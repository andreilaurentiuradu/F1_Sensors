#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "structs.h"

typedef void (*function_ptr)(void *);
void get_operations(void **operations);
void read_tire_sensor(tire_sensor *s, FILE *in);
void print_tire_sensor(tire_sensor *s);
void read_PMU(power_management_unit *s, FILE *in);
void print_PMU(power_management_unit *s);
int cmpfunc(const void *a, const void *b);
void swap_sensors(sensor *a, sensor *b);
void analyze(sensor *s, function_ptr *op);
void clear_sensors(sensor s[], int *nr_senzori);
void delete_sensor(sensor *s, int index, int *nr_senzori);
int check_TIRE(tire_sensor *s);
int check_PMU(power_management_unit *s);

int main(int argc, char const *argv[])
{
	// DECLARARI SI ALOCARI DE MEMORIE
	int nr_senzori, tip_senzor;
	FILE *in = fopen(argv[1], "rb");
	function_ptr *op = (function_ptr *)malloc(8 * sizeof(function_ptr));

	// //OPERATII EFECTIVE
	get_operations((void **)(op));
	fread(&nr_senzori, sizeof(nr_senzori), 1, in);
	// printf("nr_senzori: %d\n", nr_senzori);
	//   alocam memorie pentru vectorul de senzori
	sensor *sen = (sensor *)malloc(nr_senzori * sizeof(sensor));
	for (int i = 0; i < nr_senzori; ++i) {
		fread(&tip_senzor, sizeof(tip_senzor), 1, in);

		if (tip_senzor == 1) {         // senzor de tip PMU
			sen[i].sensor_type = PMU;  // punem campul pe PMU
			sen[i].sensor_data =
				(power_management_unit *)malloc(sizeof(power_management_unit));
			read_PMU((power_management_unit *)(sen[i].sensor_data), in);
			// print_PMU((power_management_unit *)(sen[i].sensor_data));
		} else {
			sen[i].sensor_type = TIRE;  // punem campul pe PMU
			sen[i].sensor_data = (tire_sensor *)malloc(sizeof(tire_sensor));
			read_tire_sensor((tire_sensor *)(sen[i].sensor_data), in);
			// print_tire_sensor((tire_sensor *)(sen[i].sensor_data));
		}
		fread(&sen[i].nr_operations, sizeof(int), 1, in);
		sen[i].operations_idxs =
			(int *)malloc(sen[i].nr_operations * sizeof(int));

		for (int j = 0; j < sen[i].nr_operations; ++j) {
			fread(&sen[i].operations_idxs[j], sizeof(int), 1, in);
		}
		// printf("\n\n");
	}
	// bubble sort
	int not_sorted = 1;
	while (not_sorted) {
		not_sorted = 0;
		for (int i = 0; i < nr_senzori - 1; ++i) {
			if (cmpfunc(&sen[i], &sen[i + 1]) > 0) {
				swap_sensors(&sen[i], &sen[i + 1]);
				not_sorted = 1;
			}
		}
	}

	// delete_sensor(sen, 0, &nr_senzori);
	char *operation = (char *)malloc(100 * sizeof(char));
	int index;
	do {
		scanf("%s", operation);
		// fscanf(temporar, "%s", operation);
		//  printf("operatia este %s\n", operation);
		if (strcmp(operation, "print") == 0) {
			scanf("%d", &index);
			// fscanf(temporar, "%d", &index);
			//  printf("indexul este %d\n", index);

			if (index < 0 || index >= nr_senzori) {
				// fprintf(out, "Index not in range!\n");
				printf("Index not in range!\n");
			} else {
				if (sen[index].sensor_type == PMU)
					print_PMU(
						(power_management_unit *)(sen[index].sensor_data));
				if (sen[index].sensor_type == TIRE)
					print_tire_sensor((tire_sensor *)(sen[index].sensor_data));
			}
		}

		if (strcmp(operation, "analyze") == 0) {
			scanf("%d", &index);
			// fscanf(temporar, "%d", &index);

			// printf("indexul este %d\n", index);

			if (index < 0 || index >= nr_senzori) {
				// fprintf(out, "Index not in range!\n");
				printf("Index not in range!\n");
			} else {
				analyze(&sen[index], op);
			}
		}

		if (strcmp(operation, "clear") == 0) {
			// printf("nr de senzori inainte: %d\n", nr_senzori);

			clear_sensors(sen, &nr_senzori);
			// printf("nr de senzori dupa: %d\n", nr_senzori);
		}
		if (strcmp(operation, "exit") == 0) {
			break;
		}
	} while (1);

	// ELIBERARI DE MEMORIE
	for (int i = 0; i < nr_senzori; ++i) {
		free(sen[i].sensor_data);  // eliberam memoria pentru
		// sen[i].sensor_data(campul care retine practic senzorul)
		free(sen[i].operations_idxs);
	}
	free(operation);
	free(op);  // vect de operatii
	// if(nr_senzori)
	free(sen);   // eliberez memoria ocupata de vectorul de senzori
	fclose(in);  // inchidem fisierul binar din care am citit
	return 0;
}

// to do
// 3 verifici de ce nu iei puncte pe checker pentru clean
// 5 verifici sa nu ai leakuri de memorie
// 6 coding style si readme
// 7 de pus freeurile la exit
// sen->sensor_type = PMU;
// if(sen->sensor_type == PMU)
// {
// 	sen->sensor_data = (tire_sensor *)malloc(sizeof(tire_sensor)); // aloc
// memorie pentru variabile de tip tire_sensor
// 	((tire_sensor *)sen->sensor_data)->temperature = 500; // fac castul la
// tire_sensor pentru a avea acces la campuri

// 	op[sen->operations_idxs[0]](sen->sensor_data);
// }

// // sen->sensor_type->temperature = 50;
// get_operations((void **)sen->operations_idxs);
// sen->operations_idxs[1]((void *) sen);
// sen->operations_idxs[0](NULL);
// int (* anotherFunction)(int, int)
