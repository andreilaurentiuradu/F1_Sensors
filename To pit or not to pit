#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "structs.h"

typedef void (*function_ptr)(void *);
void get_operations(void **operations);
void read_tire_sensor(tire_sensor *s, FILE *in);
void print_tire_sensor(tire_sensor *s);
void read_PMU(power_management_unit *s, FILE *in);
void print_PMU(power_management_unit *s);
int cmpfunc(const void *a, const void *b);
void swap_sensors(sensor *a, sensor *b);
void analyze(sensor *s, function_ptr *op);

int check_PMU(power_management_unit *s) {
    // if(s->voltage > 18 && s->voltage < 19)
    //     return 0;
    if (s->voltage < 10 || s->voltage > 20) return 0;
    if (s->current < -100 || s->current > 100) return 0;
    if (s->power_consumption < 0 || s->power_consumption > 1000) return 0;
    if (s->energy_regen < 0 || s->energy_regen > 100) return 0;
    if (s->energy_storage < 0 || s->energy_storage > 100) return 0;
    return 1;
}

int check_TIRE(tire_sensor *s) {
    if (s->pressure < 19 || s->pressure > 28) return 0;
    if (s->temperature < 0 || s->temperature > 120) return 0;
    if (s->wear_level < 0 || s->wear_level > 100) return 0;
    return 1;
}

void delete_sensor(sensor *s, int index, int *nr_senzori) {
    free(s[index].operations_idxs);
    free(s[index].sensor_data);
    for (int i = index + 1; i < (*nr_senzori); ++i) {
        s[i - 1] = s[i];
    }
    (*nr_senzori)--;
    // s = realloc(s, (*nr_senzori));
}

void clear_sensors(sensor s[], int *nr_senzori) {
    for (int i = 0; i < (*nr_senzori); ++i) {
        if (s[i].sensor_type == TIRE &&
            !check_TIRE((tire_sensor *)(s[i].sensor_data))) {
            delete_sensor(s, i, nr_senzori);
            --i;
        }
        if (s[i].sensor_type == PMU &&
            !check_PMU((power_management_unit *)(s[i].sensor_data))) {
            delete_sensor(s, i, nr_senzori);
            --i;
        }
    }
}
int main(int argc, char const *argv[]) {
    // DECLARARI SI ALOCARI DE MEMORIE
    int nr_senzori, tip_senzor;
    // FILE *out = fopen("output_ana", "w");
    // FILE *temporar = fopen("input_ana", "r");
    FILE *in = fopen(argv[1], "rb");
    function_ptr *op = (function_ptr *)malloc(8 * sizeof(function_ptr));

    // //OPERATII EFECTIVE
    get_operations((void **)(op));
    fread(&nr_senzori, sizeof(nr_senzori), 1, in);
    // printf("nr_senzori: %d\n", nr_senzori);
    //   alocam memorie pentru vectorul de senzori
    sensor *sen = (sensor *)malloc(nr_senzori * sizeof(sensor));
    for (int i = 0; i < nr_senzori; ++i) {
        fread(&tip_senzor, sizeof(tip_senzor), 1, in);

        if (tip_senzor == 1) {         // senzor de tip PMU
            sen[i].sensor_type = PMU;  // punem campul pe PMU
            sen[i].sensor_data =
                (power_management_unit *)malloc(sizeof(power_management_unit));
            read_PMU((power_management_unit *)(sen[i].sensor_data), in);
            // print_PMU((power_management_unit *)(sen[i].sensor_data));
        } else {
            sen[i].sensor_type = TIRE;  // punem campul pe PMU
            sen[i].sensor_data = (tire_sensor *)malloc(sizeof(tire_sensor));
            read_tire_sensor((tire_sensor *)(sen[i].sensor_data), in);
            // print_tire_sensor((tire_sensor *)(sen[i].sensor_data));
        }
        fread(&sen[i].nr_operations, sizeof(int), 1, in);
        sen[i].operations_idxs =
            (int *)malloc(sen[i].nr_operations * sizeof(int));

        for (int j = 0; j < sen[i].nr_operations; ++j) {
            fread(&sen[i].operations_idxs[j], sizeof(int), 1, in);
        }
        // printf("\n\n");
    }
    // printf("ACUM SORTAM VECTORUL\n");

    // bubble sort
    int not_sorted = 1;
    while (not_sorted) {
        not_sorted = 0;
        for (int i = 0; i < nr_senzori - 1; ++i) {
            if (cmpfunc(&sen[i], &sen[i + 1]) > 0) {
                swap_sensors(&sen[i], &sen[i + 1]);
                not_sorted = 1;
            }
        }
    }

    // delete_sensor(sen, 0, &nr_senzori);
    char *operation = (char *)malloc(100 * sizeof(char));
    int index;
    do {
        scanf("%s", operation);
        // fscanf(temporar, "%s", operation);
        //  printf("operatia este %s\n", operation);
        if (strcmp(operation, "print") == 0) {
            scanf("%d", &index);
            // fscanf(temporar, "%d", &index);
            //  printf("indexul este %d\n", index);

            if (index < 0 || index >= nr_senzori) {
                // fprintf(out, "Index not in range!\n");
                printf("Index not in range!\n");
            } else {
                if (sen[index].sensor_type == PMU)
                    print_PMU(
                        (power_management_unit *)(sen[index].sensor_data));
                if (sen[index].sensor_type == TIRE)
                    print_tire_sensor((tire_sensor *)(sen[index].sensor_data));
            }
        }

        if (strcmp(operation, "analyze") == 0) {
            scanf("%d", &index);
            // fscanf(temporar, "%d", &index);

            // printf("indexul este %d\n", index);

            if (index < 0 || index >= nr_senzori) {
                // fprintf(out, "Index not in range!\n");
                printf("Index not in range!\n");
            } else {
                analyze(&sen[index], op);
            }
        }

        if (strcmp(operation, "clear") == 0) {
            // printf("nr de senzori inainte: %d\n", nr_senzori);

            clear_sensors(sen, &nr_senzori);
            // printf("nr de senzori dupa: %d\n", nr_senzori);
        }
        if (strcmp(operation, "exit") == 0) {
            break;
        }
    } while (1);

    // ELIBERARI DE MEMORIE
    for (int i = 0; i < nr_senzori; ++i) {
        free(sen[i].sensor_data);  // eliberam memoria pentru
        // sen[i].sensor_data(campul care retine practic senzorul)
        free(sen[i].operations_idxs);
    }
    free(operation);
    free(op);    // vect de operatii
    //if(nr_senzori)
    free(sen);   // eliberez memoria ocupata de vectorul de senzori
    fclose(in);  // inchidem fisierul binar din care am citit
    return 0;
}

// to do
// 3 verifici de ce nu iei puncte pe checker pentru clean
// 5 verifici sa nu ai leakuri de memorie
// 6 coding style si readme
// 7 de pus freeurile la exit
// sen->sensor_type = PMU;
// if(sen->sensor_type == PMU)
// {
// 	sen->sensor_data = (tire_sensor *)malloc(sizeof(tire_sensor)); // aloc
// memorie pentru variabile de tip tire_sensor
// 	((tire_sensor *)sen->sensor_data)->temperature = 500; // fac castul la
// tire_sensor pentru a avea acces la campuri

// 	op[sen->operations_idxs[0]](sen->sensor_data);
// }

// // sen->sensor_type->temperature = 50;
// get_operations((void **)sen->operations_idxs);
// sen->operations_idxs[1]((void *) sen);
// sen->operations_idxs[0](NULL);
// int (* anotherFunction)(int, int)
